{"name":"Squealer","body":"# Squealer, a non-ORM, non-framework\r\n\r\nThe problem with frameworks and ORMs is that they assume certain qualities about the problem you might wish to solve and/or box you into one model. It's been the experience of many people that the \"have a hammer, everything's a nail\" approach fails more often than it succeeds once projects grow past the proof of concept stage. Some smart folks once said \"use libraries, not frameworks.\"\r\n\r\nSquealer is even less than that. It is a tool for generating code based on the schema of your database.\r\n\r\n## Pain Points Addressed\r\n\r\nOne of the difficulties with working with SQL statements in code is that they're not typed checked. Furthermore, it's often at run-time that you discover that one or many tables have changed. Once a change is permanent you have to crawl through your code to find every reference to said tables in queries you've written and modify them accordingly. Worse yet, you may need to update source code to handle these changes. All of these activities are time consuming and tedious with the compiler helping very little of the time.\r\n\r\nSquealer won't help you solve any logical inconsistencies that result from schema changes and isn't designed to do so. That would be magical. Instead it will do the following for you:\r\n* Generate code which matches the new schema, thereby causing a compile time failure if data-types have changed, columns renamed, or columns removed\r\n* Record comments made by DBAs directly into source code so developers can stay abreast of happenings at the DB layer\r\n* Record default values directly into source code\r\n* Wrap nullable fields in Options (the no null policy enforcement)\r\n* Add JDBC visible constraints as assumptions so no truncation errors will happen without a run-time exception being thrown (and working on putting compile time checking where applicable.)\r\n* Override the hashCode and equals methods to be based off the primary keys of a table (where applicable and still in debate.)\r\n\r\n## How it works\r\n\r\nYou write a config file for your database and the tables you want Squealer to produce. This config file should be in a [HOCON](https://github.com/typesafehub/config) friendly format:\r\n\r\n    {\r\n      user: myAccount\r\n      password: myPassword\r\n      url: myDB_URL\r\n      tables: {\r\n        package: foo\r\n        names: [users, u2bill, accounts, a2bill, charges, charge2bill, billables, balance]\r\n      }\r\n    }\r\n\r\nIt should include a user, password and url to connect to your database as well as an optional list of tables with package name to be written. Careful in choosing your package names as Squealer will create the directory structure for the package if not found, i.e. if you misspelled something.\r\n\r\nYou then run Squealer as a command line tool, giving as arguments the names of the config files you wish to be ran. Squealer can not currently handle multiple databases. You will need a separate config for each one.\r\n\r\nSquealer then connects to your database, parses the schema and generates the code. The code generated respects the default values for a table, the fact that columns can be null, and will use the primary key for hashCode and equals methods (or multiple columns if a compound primary key is present.)\r\n\r\nFrom the above config file we'd expect a sample of the code produced from our mythical DB to look like:\r\n\r\n    package com.foo\r\n    import java.sql._\r\n\r\n    object Users{\r\n      def apply(result: ResultSet) = new Users(result.getInt(\"id\"), Option(result.getString(\"name\")))\r\n    }\r\n\r\n    //Users was created on 5/12/2012\r\n    //@name Made name nullable to delete users but retain anonymous record of activities\r\n    case class Users(bar: Int = 0, name: Option[String]){\r\n      name.map(x => assume(x.length < 255, \"name must be less than 255 in length\")\r\n      override def hashCode = bar\r\n      override def equals(that: Any) = that match{\r\n        case Users(bar, _) => this.bar == that.bar\r\n        case _ => false\r\n      }\r\n    }\r\n\r\nWhich would be placed in the _/src/main/scala/com/foo/_ directory in the file _Users.scala_.\r\n\r\n## Future Plans\r\n\r\nSquealer is great for making a reference to plain data tables as they exist in the database. Most of the time, though, people don't query an entire table. They often write JOINS and have non-trivial SELECT clauses. Several areas for improvement which are being currently looked at or warrant exploration are:\r\n\r\n1. Parsing arbitrary SQL statements, validating those statements against the schema, and generating classes for them. This is not a trivial exercise.\r\n\r\n2. Adding in SBT hooks.\r\n\r\n3. Adding additional languages other than just Scala.\r\n\r\n4. Anything else the community wants/feels would benefit them.","tagline":"A non-ORM based code generator for DB interaction","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}